/*
ЗАДАЧА 1
Формулировка
Сколько монет в среднем списывает пользователь за весь срок жизни? Сколько монет ему начисляется?
Какая дельта между этими двумя метриками?
В расчетах исключайте пользователей с id < 94 - это наши внутренние аккаунты.
Когда будете работать с таблицей Транзакций, не берите в расчет транзакции больше 500 монет - это начисления бета-тестерам,
они будут мешать.

Решение студента:
*/
with A as (select sum(t.value) as sum_value,  
              	t.user_id              	 
             	from transaction t
             	where t.type_id in(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,29) --id начислений
             	and t.value<=500
             	and t.user_id>=94
             	group by t.user_id
        	), --начисление по каждому юзеру
 	A1 as (select round (sum(A.sum_value)/count(A.user_id), 2) as среднее_начисление
        	from A), /*вывод среднего начисления */  
 	B as (select round(sum(t.value)*1.0/count(A.user_id ), 2) as среднее_списание
             	from A
             	left join transaction t on t.user_id =A.user_id
             	where t.type_id in(1,23,24,25,26,27,28) --id списаний
             	and t.value<=500
             	and t.user_id>=94
       	) /*вывод среднего списания */      	 
      	select A1.среднее_начисление,
             	B.среднее_списание,
             	A1.среднее_начисление-B.среднее_списание as дельта
      	from A1, B

/*
Комментарий Dmytry Ch. Dwisler:

Задача решена не верно. 
Начисления посчитаны правильно, а списания и баланс - нет.
Если считать списания по аналогии с начислениями, то нужно сначала создать для этого СТЕ “B”, где тот же код, что и в СТЕ “А”, но WHERE t.type_id NOT IN(...), 
но лучше поменять местами IN и NOT IN, чтобы в СТЕ “А” расчета начислений было WHERE t.type_id NOT IN (1,23,24,25,26,27,28), а в СТЕ “В” расчета списаний - WHERE t.type_id IN (1,23,24,25,26,27,28). 
Так меньше условий отбора перечислять в скобках.
Следуя заданной в решении студента логике кода, можно исправить расчет баланса, для этого надо создать еще одну СТЕ “С”. Но в ситуации с балансом необходимо будет считать по каждому юзеру не только что-то одно (списания/начисления), 
что было ранее реализовано условием WHERE, а как операции начисления, так и списания, для этого нужно будет просуммировать все операции, но списаниям при этом, до суммирования, присвоить знак минус “-”, что можно реализовать через CASE WHEN. 
В условиях WHERE отбор type_id, соответственно, надо убрать.
Чтобы не плодить еще лишних СТЕ, их при таком решении и так уже три, окончательные выводы значений реализовать последним основным запросом. Для этого в нем можно написать подзапросы аналогично реализованному в СТЕ “А1” 
(но вместо деления суммы операций на количество юзеров можно использовать avg(sum_value)). Но лучше сделать джоин 3х реализованных выше СТЕ по user_id. Джоинить необходимо к СТЕ “С” по ЛЕФТ ДЖОИН, в ней самые полные данные по юзерам, 
т.к. нет условия WHERE, отсекающего юзеров по списаниям/начислениям, как в СТЕ “А” и “В”.

Что касается форматирования:
вероятно, стоит давать логично идентифицируемые наименования СТЕ
внутри операторов SELECT, WHERE, FROM и т.п. писать каждую новую колонку, условие и т.д. с новой строки и делать отступы
зарезервированные СУБД слова типа “transaction” брать в кавычки
делать отступы до/после арифметических знаков, после запятых
не делать отступы перед скобками, пунктуационными знаками
давать все наименования латинскими буквами, в т.ч. создаваемым колонкам, например, среднее_начисление - avg_accrual

	Скорректированный по описанным выше условиям исходный код:
*/
with accruals as ( -----наименования СТЕ
	select sum(t.value) as sum_value,  -----отступы
			t.user_id              	 
	from "transaction" t	-----зарезервированные системой наименования брать в двойные кавычки
	where t.type_id not in (1, 23, 24, 25, 26, 27, 28) --id начислений
		and t.value <= 500	-----отступы до/после арифметических знаков, после запятых
		and t.user_id >= 94
	group by t.user_id
        	), --начисление по каждому юзеру
	withdrawals as (
 	select sum(t.value) as sum_value,  
			t.user_id              	 
	from "transaction" t
	where t.type_id in (1, 23, 24, 25, 26, 27, 28) --id начислений
		and t.value <= 500
		and t.user_id >= 94
	group by t.user_id
        	), --списание по каждому юзеру    
	all_operations as (
	select sum(
			case
				when t.type_id in (1, 23, 24, 25, 26, 27, 28) 
					then -t.value	-----списания
					else t.value	-----начисления
			end) as sum_value,  -----сумма всех операций юзера (списаниям предварительно присваивается знак минус)
		t.user_id              	 
	from "transaction" t
	where t.value <= 500
		and t.user_id >= 94
	group by t.user_id
        	) -----баланс по каждому юзеру           	 	
select 
	round(avg(a.sum_value), 2) as avg_accrual, -----наименования колонок латинскими буквами
	round(avg(w.sum_value), 2) as avg_withdrawal,
	round(avg(o.sum_value), 2) as avg_balance
from all_operations as o
	left join accruals as a on o.user_id = a.user_id
	left join withdrawals as w on o.user_id = w.user_id

/*
Вообще, для решения данной задачи оптимальнее создать одну СТЕ, в которой реализовать все условия CASE WHEN под три колонки: начисления, списания и все операции. 
Затем в тексте основного запроса сослаться на эту СТЕ для расчета средних значений:
*/
with users_operations as (
	select 
		user_id,
		sum(case
			when type_id not in (1,23,24,25,26,27,28)
				then value
			end) as accruals,
		sum(case
			when type_id in (1,23,24,25,26,27,28)
				then -value
			end) as withdrawals,
		sum(case
			when type_id in (1,23,24,25,26,27,28)
				then -value
			else value
			end) as all_operations
	from "transaction" t 
	where user_id >= 94
		and value <= 500
	group by user_id
	)
select 
	round(avg(accruals), 2) as avg_accrual,
	round(avg(withdrawals), 2) as avg_withdrawal,
	round(avg(all_operations), 2) as avg_balance
from users_operations

